# Customer Frontend - NFR Requirements

## 개요
이 문서는 customer-frontend 유닛의 비기능 요구사항(Non-Functional Requirements)을 정의합니다.

---

## 1. 확장성 요구사항

### 1.1 동시 사용자 수
**요구사항**: 레스토랑당 10-50개 태블릿 동시 지원

**근거**: 중형 레스토랑 규모를 타겟으로 함

**구현 고려사항**:
- React Query 캐시 최적화로 서버 부하 감소
- localStorage 사용으로 클라이언트 측 상태 관리
- 각 태블릿은 독립적으로 작동 (서버 의존성 최소화)

**측정 지표**:
- 동시 접속 태블릿 수: 50개
- 태블릿당 평균 세션 시간: 30-60분

---

### 1.2 데이터 증가 패턴
**요구사항**: localStorage에 1-5MB 데이터 저장 지원

**저장 데이터**:
- 장바구니 데이터: ~100KB (최대 10개 항목)
- 캐시된 메뉴 데이터: ~500KB-2MB (50개 항목 + 이미지 URL)
- 세션 데이터: ~10KB
- 주문 내역: ~500KB (세션당 최대 20개 주문)

**구현 고려사항**:
- localStorage 용량 모니터링
- 용량 초과 시 가장 오래된 항목 제거
- 이미지는 URL만 저장 (Base64 저장 금지)

**측정 지표**:
- 평균 localStorage 사용량: 1-2MB
- 최대 localStorage 사용량: 5MB

---

### 1.3 메뉴 데이터 크기
**요구사항**: 소형 메뉴 (< 50개 항목) 지원

**메뉴 데이터 구조**:
- 메뉴 항목당 크기: ~10KB (메타데이터 + 이미지 URL)
- 총 메뉴 데이터: ~500KB (50개 항목)
- 카테고리 데이터: ~5KB (10개 카테고리)

**구현 고려사항**:
- React Query로 메뉴 데이터 캐싱 (staleTime: 5분)
- 이미지 지연 로딩으로 초기 로드 최적화
- 카테고리별 필터링으로 렌더링 최적화

**측정 지표**:
- 메뉴 데이터 로드 시간: < 500ms
- 메뉴 렌더링 시간: < 300ms

---

## 2. 성능 요구사항

### 2.1 페이지 로드 시간
**요구사항**: 초기 페이지 로드 < 2초

**측정 지표**:
- **FCP (First Contentful Paint)**: < 1초
- **LCP (Largest Contentful Paint)**: < 2초
- **TTI (Time to Interactive)**: < 2.5초

**구현 전략**:
- Code splitting으로 초기 번들 크기 최소화
- Critical CSS 인라인 처리
- 폰트 최적화 (font-display: swap)
- 이미지 지연 로딩
- Service Worker로 정적 자산 캐싱

**번들 크기 목표**:
- 초기 JS 번들: < 200KB (gzipped)
- 초기 CSS 번들: < 50KB (gzipped)
- 총 초기 로드: < 300KB (gzipped)

---

### 2.2 API 응답 시간
**요구사항**: 중요 작업 API 응답 < 500ms

**중요 작업**:
- 로그인: < 500ms
- 주문 제출: < 500ms
- 메뉴 조회: < 500ms
- 주문 내역 조회: < 500ms

**구현 전략**:
- Axios 인터셉터로 요청/응답 최적화
- React Query로 중복 요청 방지
- 낙관적 업데이트로 체감 속도 향상
- 지수 백오프 재시도로 일시적 실패 처리

**측정 지표**:
- P50 응답 시간: < 300ms
- P95 응답 시간: < 500ms
- P99 응답 시간: < 1초

---

### 2.3 UI 반응성
**요구사항**: UI 상호작용 지연 < 300ms

**상호작용 유형**:
- 버튼 클릭: < 100ms (시각적 피드백)
- 장바구니 업데이트: < 300ms (계산 + 렌더링)
- 카테고리 필터링: < 200ms
- 모달 열기/닫기: < 200ms

**구현 전략**:
- React 18 자동 배칭으로 렌더링 최적화
- useMemo/useCallback로 불필요한 재계산 방지
- 가상 스크롤링 (필요 시)
- 디바운싱/쓰로틀링 적용

**측정 지표**:
- 평균 상호작용 지연: < 200ms
- 최대 상호작용 지연: < 300ms

---

### 2.4 이미지 로딩
**요구사항**: 지연 로딩 + 플레이스홀더

**구현 전략**:
- Intersection Observer API로 지연 로딩
- 플레이스홀더 이미지 표시 (로딩 중)
- 이미지 최적화 (WebP 형식, 적절한 해상도)
- 이미지 CDN 사용 (가능 시)

**이미지 사양**:
- 메뉴 이미지 크기: 400x300px (썸네일)
- 이미지 형식: WebP (fallback: JPEG)
- 이미지 품질: 80%
- 평균 이미지 크기: 30-50KB

**측정 지표**:
- 이미지 로드 시간: < 500ms
- 뷰포트 내 이미지 우선 로드
- 스크롤 시 부드러운 로딩

---

## 3. 가용성 요구사항

### 3.1 가동 시간
**요구사항**: 99% 가동 시간 (연간 3.65일 다운타임)

**가용성 전략**:
- 프론트엔드는 정적 자산이므로 높은 가용성 보장
- CDN 사용으로 지리적 분산
- 에러 경계로 부분 장애 격리
- 폴백 UI 제공

**다운타임 허용**:
- 계획된 유지보수: 월 1회, 최대 2시간
- 비계획 다운타임: 연간 최대 3일

**측정 지표**:
- 월간 가동 시간: > 99%
- 평균 복구 시간 (MTTR): < 1시간

---

### 3.2 오프라인 기능
**요구사항**: 부분 오프라인 모드 (캐시된 메뉴 탐색)

**오프라인 기능**:
- ✅ 캐시된 메뉴 조회
- ✅ 장바구니 관리 (localStorage)
- ❌ 주문 제출 (인터넷 필요)
- ❌ 주문 내역 조회 (인터넷 필요)

**구현 전략**:
- Service Worker로 정적 자산 캐싱
- React Query 캐시로 메뉴 데이터 오프라인 접근
- 오프라인 감지 및 사용자 알림
- 온라인 복구 시 자동 동기화

**사용자 경험**:
- 오프라인 상태 표시 (배너 또는 아이콘)
- 오프라인에서 불가능한 작업 비활성화
- 온라인 복구 시 알림

---

### 3.3 세션 지속성
**요구사항**: 테이블 세션 종료 시까지 유지

**세션 관리**:
- 세션 저장소: localStorage
- 세션 만료: 관리자가 테이블 세션 종료 시
- 브라우저 재시작 후 자동 복원

**구현 전략**:
- localStorage에 세션 데이터 저장
- 앱 시작 시 세션 유효성 검증
- 세션 만료 시 자동 연장 시도
- 세션 종료 시 localStorage 정리

**측정 지표**:
- 세션 복원 성공률: > 99%
- 세션 복원 시간: < 500ms

---

## 4. 보안 요구사항

### 4.1 인증 보안
**요구사항**: 기본 수준 (JWT + HTTPS)

**인증 메커니즘**:
- JWT 토큰 기반 인증
- localStorage에 토큰 저장
- HTTPS 통신 필수
- 토큰 만료 시 자동 연장

**보안 조치**:
- HTTPS 강제 (HTTP → HTTPS 리다이렉트)
- JWT 토큰 검증 (서버 측)
- 토큰 만료 시간: 16시간 (테이블 세션)
- XSS 방어 (React 기본 이스케이프)

**위협 모델**:
- ✅ 중간자 공격 (MITM) - HTTPS로 방어
- ✅ 토큰 탈취 - localStorage (XSS 위험 존재)
- ⚠️ XSS 공격 - React 기본 방어 + CSP
- ❌ CSRF 공격 - JWT 사용으로 CSRF 토큰 불필요

---

### 4.2 데이터 보호
**요구사항**: 모든 데이터 암호화 (장바구니, 세션, 토큰)

**암호화 대상**:
- JWT 토큰: AES-256 암호화
- 세션 데이터: AES-256 암호화
- 장바구니 데이터: AES-256 암호화

**구현 전략**:
- crypto-js 라이브러리 사용
- 암호화 키: 환경 변수로 관리
- localStorage 저장 전 암호화
- localStorage 읽기 후 복호화

**보안 고려사항**:
- 암호화 키 노출 방지
- 키 로테이션 전략 (필요 시)
- 암호화 성능 영향 최소화

---

### 4.3 XSS 방어
**요구사항**: 강화 수준 (CSP + 입력 살균)

**방어 메커니즘**:
1. **React 기본 이스케이프**: JSX 자동 이스케이프
2. **CSP (Content Security Policy)**: HTTP 헤더 설정
3. **입력 살균**: 사용자 입력 검증 및 살균
4. **dangerouslySetInnerHTML 금지**: 사용 금지 원칙

**CSP 정책**:
```
Content-Security-Policy:
  default-src 'self';
  script-src 'self' 'unsafe-inline';
  style-src 'self' 'unsafe-inline';
  img-src 'self' data: https:;
  font-src 'self' data:;
  connect-src 'self' https://api.example.com;
```

**입력 검증**:
- 모든 사용자 입력 검증
- 특수 문자 이스케이프
- HTML 태그 제거

---

### 4.4 API 보안
**요구사항**: HTTPS + JWT + 속도 제한 + 요청 서명

**보안 조치**:
1. **HTTPS**: 모든 API 통신 암호화
2. **JWT 인증**: Authorization 헤더에 토큰 포함
3. **속도 제한**: 클라이언트 측 요청 제한 (초당 10회)
4. **요청 서명**: HMAC-SHA256으로 요청 무결성 검증

**요청 서명 구현**:
```typescript
// 요청 서명 생성
const signature = HMAC_SHA256(
  method + url + timestamp + body,
  secretKey
);

// 헤더에 포함
headers: {
  'X-Signature': signature,
  'X-Timestamp': timestamp
}
```

**API 보안 체크리스트**:
- ✅ HTTPS 통신
- ✅ JWT 토큰 인증
- ✅ 요청 서명 검증
- ✅ 타임스탬프 검증 (재생 공격 방지)
- ✅ 속도 제한 (DDoS 방지)

---

## 5. 신뢰성 요구사항

### 5.1 에러 처리
**요구사항**: 강화 수준 (에러 로깅 + 재시도)

**에러 처리 전략**:
1. **에러 경계 (Error Boundary)**: React 컴포넌트 에러 격리
2. **try-catch**: 비동기 작업 에러 처리
3. **토스트 알림**: 사용자 친화적 에러 메시지
4. **에러 로깅**: Sentry 또는 유사 서비스
5. **재시도 로직**: 지수 백오프

**에러 분류**:
- **치명적 에러**: 앱 전체 중단 (에러 경계로 처리)
- **복구 가능 에러**: 재시도 가능 (네트워크 에러)
- **사용자 에러**: 입력 검증 실패 (인라인 메시지)

**에러 로깅 정보**:
- 에러 메시지 및 스택 트레이스
- 사용자 컨텍스트 (세션 ID, 테이블 ID)
- 브라우저 정보 (User-Agent)
- 타임스탬프

---

### 5.2 재시도 로직
**요구사항**: 지수 백오프 (1초, 2초, 4초) - 최대 3회

**재시도 전략**:
```typescript
const retryDelays = [1000, 2000, 4000]; // ms
const maxRetries = 3;

async function retryWithBackoff(fn, retries = 0) {
  try {
    return await fn();
  } catch (error) {
    if (retries >= maxRetries) throw error;
    
    const delay = retryDelays[retries];
    await sleep(delay);
    
    return retryWithBackoff(fn, retries + 1);
  }
}
```

**재시도 대상**:
- ✅ 네트워크 에러 (ECONNABORTED, ENOTFOUND)
- ✅ 5xx 서버 에러
- ✅ 타임아웃 에러
- ❌ 4xx 클라이언트 에러 (재시도 불필요)
- ❌ 인증 에러 (401, 403)

**재시도 제외**:
- 주문 제출 (중복 주문 방지)
- 결제 관련 작업

---

### 5.3 모니터링
**요구사항**: 고급 수준 (성능 모니터링 + 사용자 분석)

**모니터링 도구**:
1. **에러 추적**: Sentry
2. **성능 모니터링**: Google Analytics + Web Vitals
3. **사용자 분석**: Google Analytics 또는 Mixpanel

**모니터링 지표**:
- **에러율**: 에러 발생 빈도 및 유형
- **성능 지표**: FCP, LCP, TTI, CLS
- **사용자 행동**: 페이지 뷰, 클릭, 전환율
- **API 성능**: 응답 시간, 실패율

**알림 설정**:
- 에러율 > 5%: 즉시 알림
- API 실패율 > 10%: 즉시 알림
- LCP > 3초: 경고 알림

---

## 6. 사용성 요구사항

### 6.1 접근성
**요구사항**: WCAG 2.1 Level AA

**접근성 기준**:
- **지각 가능성 (Perceivable)**:
  - 텍스트 대체 (이미지 alt 속성)
  - 색상 대비 4.5:1 이상
  - 텍스트 크기 조정 가능
  
- **운용 가능성 (Operable)**:
  - 키보드 접근 가능
  - 충분한 시간 제공 (타임아웃 경고)
  - 포커스 표시
  
- **이해 가능성 (Understandable)**:
  - 명확한 레이블
  - 일관된 네비게이션
  - 에러 메시지 명확
  
- **견고성 (Robust)**:
  - 시맨틱 HTML
  - ARIA 속성 사용

**접근성 테스트**:
- axe-core 자동 테스트
- 스크린 리더 테스트 (NVDA, JAWS)
- 키보드 네비게이션 테스트

---

### 6.2 터치 타겟 크기
**요구사항**: 최소 44x44px (iOS 가이드라인)

**터치 타겟 사양**:
- 버튼: 최소 44x44px
- 링크: 최소 44x44px
- 입력 필드: 최소 44px 높이
- 체크박스/라디오: 최소 44x44px

**구현 가이드라인**:
- 터치 타겟 간 최소 8px 간격
- 중요 버튼은 더 크게 (예: 주문하기 버튼 56x56px)
- 터치 피드백 제공 (active 상태)

---

### 6.3 반응형 디자인
**요구사항**: 모든 기기 지원 (태블릿 + 모바일 + 데스크톱)

**브레이크포인트**:
- 모바일: < 768px
- 태블릿: 768px - 1024px
- 데스크톱: > 1024px

**반응형 전략**:
- Mobile-first 접근
- Flexbox/Grid 레이아웃
- 미디어 쿼리로 레이아웃 조정
- 이미지 반응형 (srcset)

**테스트 기기**:
- iPhone (375px, 414px)
- iPad (768px, 1024px)
- Desktop (1280px, 1920px)

---

### 6.4 국제화 (i18n)
**요구사항**: 다국어 지원 (한국어, 영어, 중국어, 일본어)

**i18n 구현**:
- **라이브러리**: react-i18next
- **번역 파일**: JSON 형식
- **언어 감지**: 브라우저 언어 또는 사용자 선택
- **폴백**: 한국어 (기본)

**번역 범위**:
- UI 텍스트 (버튼, 레이블, 메시지)
- 에러 메시지
- 알림 메시지
- 도움말 텍스트

**번역 제외**:
- 메뉴명 (데이터베이스에서 관리)
- 가격 (숫자 형식만 로케일 적용)

**로케일 형식**:
- 날짜/시간: 각 언어별 형식
- 숫자: 천 단위 구분자
- 통화: 원화 (₩) 고정

---

## 7. 추가 요구사항

### 7.1 브라우저 지원
**요구사항**: 최신 브라우저 (Chrome, Safari, Edge - 최근 2개 버전)

**지원 브라우저**:
- Chrome: 최근 2개 버전
- Safari: 최근 2개 버전
- Edge: 최근 2개 버전

**미지원 브라우저**:
- Internet Explorer (모든 버전)
- Firefox (선택적 지원)

**브라우저 감지**:
- 미지원 브라우저 접속 시 경고 메시지
- 권장 브라우저 안내

---

### 7.2 테스트 요구사항
**요구사항**: 단위 + 통합 + E2E 테스트

**테스트 전략**:
1. **단위 테스트**: Jest + React Testing Library
   - 컴포넌트 테스트
   - 유틸리티 함수 테스트
   - 커버리지 목표: 80%

2. **통합 테스트**: Jest + React Testing Library
   - 컴포넌트 간 상호작용 테스트
   - API 통합 테스트 (MSW)
   - 커버리지 목표: 70%

3. **E2E 테스트**: Playwright 또는 Cypress
   - 주요 사용자 플로우 테스트
   - 크로스 브라우저 테스트
   - 커버리지 목표: 주요 플로우 100%

**테스트 자동화**:
- CI/CD 파이프라인에 통합
- PR 생성 시 자동 실행
- 테스트 실패 시 머지 차단

---

### 7.3 성능 예산
**요구사항**: 공식 예산 없음 (최선 노력 최적화)

**성능 가이드라인**:
- 번들 크기: 가능한 작게 유지
- 로드 시간: < 2초 목표
- 이미지 최적화: WebP 사용
- 코드 스플리팅: 라우트별 분리

**성능 모니터링**:
- Lighthouse 점수: > 90 (Performance)
- Web Vitals 추적
- 번들 분석 (webpack-bundle-analyzer)

**최적화 우선순위**:
1. 초기 로드 시간 최적화
2. 이미지 최적화
3. 코드 스플리팅
4. 캐싱 전략

---

## 요약

### 핵심 NFR 요구사항

| 카테고리 | 요구사항 | 목표 |
|---------|---------|------|
| 확장성 | 동시 사용자 | 10-50개 태블릿 |
| 확장성 | 데이터 크기 | 1-5MB (localStorage) |
| 확장성 | 메뉴 크기 | < 50개 항목 |
| 성능 | 페이지 로드 | < 2초 |
| 성능 | API 응답 | < 500ms |
| 성능 | UI 반응성 | < 300ms |
| 가용성 | 가동 시간 | 99% |
| 가용성 | 오프라인 | 부분 지원 |
| 보안 | 인증 | JWT + HTTPS |
| 보안 | 데이터 보호 | AES-256 암호화 |
| 보안 | XSS 방어 | CSP + 입력 살균 |
| 신뢰성 | 에러 처리 | 강화 (로깅 + 재시도) |
| 신뢰성 | 재시도 | 지수 백오프 (3회) |
| 신뢰성 | 모니터링 | 고급 (성능 + 분석) |
| 사용성 | 접근성 | WCAG 2.1 AA |
| 사용성 | 터치 타겟 | 44x44px |
| 사용성 | 반응형 | 모든 기기 |
| 사용성 | 국제화 | 4개 언어 |
| 추가 | 브라우저 | 최신 2개 버전 |
| 추가 | 테스트 | 단위 + 통합 + E2E |
| 추가 | 성능 예산 | 최선 노력 |

**총 NFR 요구사항**: 28개 영역
